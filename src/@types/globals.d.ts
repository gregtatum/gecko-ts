interface ChromeUtils {
  // There is no type safety in tying what was imported into the type definition
  // of `lazyModules`.
  defineModuleGetters(object: any, modules: Record<string, string>): void;

  // Returning a new object improves the ergonomics here:
  defineModuleGetters2(modules: Record<string, string>): any;

  // This example is broken, but I wish there is a way to describe this.
  defineModuleGetters3<S, T extends Record<string, S>>(modules: T): {
    [Property in keyof T]: import(T[Property])
    //                            ^^^^^^^^^^^
    //                            String literal expected.ts(1141)
  };

  defineModulesGetters4<M extends Record<string, keyof Modules>>(modules: M): {
    [Property in keyof M]: Modules[M[Property]]
  }
}

declare var ChromeUtils: ChromeUtils;

// A mapping could be generated by the build system to map absolute paths to the
// list of known modules.
interface Modules {
  "resource://utils.mjs": typeof import("../utils.mjs");
  // absolute path => relative path
}
